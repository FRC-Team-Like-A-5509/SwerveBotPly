// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc5509.SwerveBotPly.subsystems;

import org.usfirst.frc5509.SwerveBotPly.RobotMap;
import org.usfirst.frc5509.SwerveBotPly.commands.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.ctre.phoenix.motorcontrol.ControlMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.SpeedController;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class DriveTrain extends Subsystem {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	private static final int TIMEOUT_MS = 10;
	private final static double WHEELBASE = 24; // Length between the axis'
	private final static double TRACKWIDTH = 17; // length between two motors on same axis
	private final static double RADIUS = Math.sqrt(Math.pow(WHEELBASE, 2) + Math.pow(TRACKWIDTH, 2));
	private final static double MAX_SPEED = 1;
	private final static double ENCODER_TICKS = 512; // amount of point in wheel rotation for encoder assuming 1024
														// encoder
	private final static double ROTATION_RATIO = 4; // rotation ratio for gearing (probably)
	private final static double CONVERT = ENCODER_TICKS * ROTATION_RATIO;
	private final static double PIDP = .1;
	private final static double PIDI = 0.0001;
	private final static double PIDD = 0;
	private final static double PIDF = 0;
	private double convertUsed = 0;

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final WPI_TalonSRX frontLeftTurn = RobotMap.driveTrainFrontLeftTurn;
	private final WPI_TalonSRX frontRightTurn = RobotMap.driveTrainFrontRightTurn;
	private final WPI_TalonSRX backLeftTurn = RobotMap.driveTrainBackLeftTurn;
	private final WPI_TalonSRX backRightTurn = RobotMap.driveTrainBackRightTurn;
	private final SpeedController frontLeftDrive = RobotMap.driveTrainFrontLeftDrive;
	private final SpeedController frontRightDrive = RobotMap.driveTrainFrontRightDrive;
	private final SpeedController backLeftDrive = RobotMap.driveTrainBackLeftDrive;
	private final SpeedController backRightDrive = RobotMap.driveTrainBackRightDrive;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	@Override
	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		setDefaultCommand(new Drive());

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	@Override
	public void periodic() {
		// Put code here to be run every loop

	}

	public void initTurnMode() {
		frontLeftTurn.setSelectedSensorPosition(0, 0, TIMEOUT_MS);
		frontRightTurn.setSelectedSensorPosition(0, 0, TIMEOUT_MS);
		backLeftTurn.setSelectedSensorPosition(0, 0, TIMEOUT_MS);
		backRightTurn.setSelectedSensorPosition(0, 0, TIMEOUT_MS);

		frontLeftTurn.setIntegralAccumulator(0, 0, TIMEOUT_MS);
		frontRightTurn.setIntegralAccumulator(0, 0, TIMEOUT_MS);
		backLeftTurn.setIntegralAccumulator(0, 0, TIMEOUT_MS);
		backRightTurn.setIntegralAccumulator(0, 0, TIMEOUT_MS);

		readControlValues();
	}

	// Put methods for controlling this subsystem
	// here. Call these from Commands.'

	public void writeDefaultValues() {
		SmartDashboard.putNumber("drivetrain_p", 2);
		SmartDashboard.putNumber("drivetrain_i", .0001);
		SmartDashboard.putNumber("drivetrain_d", 0);
		SmartDashboard.putNumber("drivetrain_f", 0);
		SmartDashboard.putNumber("drivetrain_convert", CONVERT);
	}

	public void readControlValues() {

		double p = SmartDashboard.getNumber("drivetrain_p", .1);
		double i = SmartDashboard.getNumber("drivetrain_i", .001);
		double d = SmartDashboard.getNumber("drivetrain_d", 0);
		double f = SmartDashboard.getNumber("drivetrain_f", 0);
		this.convertUsed = SmartDashboard.getNumber("drivetrain_convert", CONVERT);

		frontLeftTurn.config_kP(0, p, TIMEOUT_MS);
		frontLeftTurn.config_kI(0, i, TIMEOUT_MS);
		frontLeftTurn.config_kD(0, d, TIMEOUT_MS);
		frontLeftTurn.config_kF(0, f, TIMEOUT_MS);

		frontRightTurn.config_kP(0, p, TIMEOUT_MS);
		frontRightTurn.config_kI(0, i, TIMEOUT_MS);
		frontRightTurn.config_kD(0, d, TIMEOUT_MS);
		frontRightTurn.config_kF(0, f, TIMEOUT_MS);

		backLeftTurn.config_kP(0, p, TIMEOUT_MS);
		backLeftTurn.config_kI(0, i, TIMEOUT_MS);
		backLeftTurn.config_kD(0, d, TIMEOUT_MS);
		backLeftTurn.config_kF(0, f, TIMEOUT_MS);

		backRightTurn.config_kP(0, p, TIMEOUT_MS);
		backRightTurn.config_kI(0, i, TIMEOUT_MS);
		backRightTurn.config_kD(0, d, TIMEOUT_MS);
		backRightTurn.config_kF(0, f, TIMEOUT_MS);

	}

	public void drive(double rotation, double x, double y) {

		// calculate x/y components for wheels 1 & 3 as thats all that's needed
		double A = x - rotation * (WHEELBASE / RADIUS);
		double B = x + rotation * (WHEELBASE / RADIUS);
		double C = y - rotation * (TRACKWIDTH / RADIUS);
		double D = y + rotation * (TRACKWIDTH / RADIUS);

		double[] speeds = new double[4];
		double[] rotations = new double[4];

		// calculate speed/rotation for each wheel
		speeds[0] = Math.sqrt(Math.pow(B, 2) + Math.pow(C, 2));
		rotations[0] = Math.toDegrees(Math.atan2(B, C));

		// System.out.println("Calculated " + rotations[0]);

		speeds[1] = Math.sqrt(Math.pow(B, 2) + Math.pow(D, 2));
		rotations[1] = Math.toDegrees(Math.atan2(B, D));

		speeds[2] = Math.sqrt(Math.pow(A, 2) + Math.pow(D, 2));
		rotations[2] = Math.toDegrees(Math.atan2(A, D));

		speeds[3] = Math.sqrt(Math.pow(A, 2) + Math.pow(C, 2));
		rotations[3] = Math.toDegrees(Math.atan2(A, C));

		// normalize speeds to a good speed;
		speeds = normalizeSpeeds(speeds, x, y);

		frontRightDrive.set(speeds[0] * MAX_SPEED);
		frontLeftDrive.set(speeds[1] * MAX_SPEED);
		backLeftDrive.set(speeds[2] * MAX_SPEED);
		backRightDrive.set(speeds[3] * MAX_SPEED);

		int[] ticks = new int[4];

		for (int i = 0; i < 4; i++) {
			rotations[i] *= -1;
			ticks[i] = (int) (rotations[i] * convertUsed / 360.0);

		}

		for (int i = 0; i < 4; i++) {
			SmartDashboard.putNumber("Speed " + i, speeds[i]);
			SmartDashboard.putNumber("Rotations " + i, rotations[i]);
			SmartDashboard.putNumber("Ticks " + i, ticks[i]);

		}

		frontRightTurn.set(ControlMode.Position, ticks[0] / 3);
		frontLeftTurn.set(ControlMode.Position, ticks[1]);
		backLeftTurn.set(ControlMode.Position, ticks[2]);
		backRightTurn.set(ControlMode.Position, ticks[3] / 3);

	}

	public double[] normalizeSpeeds(double[] speeds, double movementX, double movementY) {
		double maxSpeed = speeds[0];
		double minSpeed = speeds[0];
		// find min and max speeds
		for (int i = 1; i < speeds.length; i++) {
			if (speeds[i] > maxSpeed) {
				maxSpeed = speeds[i];
			}
			if (speeds[i] < minSpeed) {
				minSpeed = speeds[i];
			}
		}
		// normalize to fastest speed
		if (maxSpeed > 1) {
			for (int i = 0; i < speeds.length; i++) {
				speeds[i] /= maxSpeed;
			}
		}
		// normalize to fastest speed if negative
		/*
		 * if (minSpeed < -1) { for (int i = 0; i < speeds.length; i++) { speeds[i] /=
		 * minSpeed * -1; } }
		 */

		// get joystick magnitude of distance (faster than joystick.getMagnitude b/c
		// FastMath
		/*
		 * double magnitude = Math.sqrt(Math.pow(movementX, 2) + Math.pow(movementY,
		 * 2)); // make sure magnitude isn't >1 // magnitude is now guaranteed to be 0
		 * <= x <= 1 where x is magnitude if (magnitude > 1) { magnitude = 1; } //
		 * normalize to magnitude for (int i = 0; i < speeds.length; i++) { speeds[i] *=
		 * magnitude; }
		 */
		return speeds;
	}

}
